===== README.md =====

# KJV Logo Coloring

A simple web application for coloring the KJV logo SVG. Users can reassign predefined color categories to different elements of the logo, with the SVG dynamically updating based on their selections. Built with TypeScript, this project leverages modern web standards and includes offline support via a service worker.

## Features
- Display and scale the `kjv-logo.svg` to fit the browser window.
- Seven fixed colors (dark blue, light blue, transparent, black, yellow, green, white) assignable to SVG elements.
- Interactive UI with a list of element IDs; click an ID to open a color picker dialog.
- Offline caching using a service worker.
- TypeScript-based with strict type checking.

## Prerequisites
- [Node.js](https://nodejs.org/) (v16 or later recommended)
- [pnpm](https://pnpm.io/) (installed globally: `npm install -g pnpm`)

## Installation
1. **Clone the repository**:
   ```bash
   git clone <repository-url>
   cd kjv-logo-coloring
   ```

2. **Install dependencies**:
   ```bash
   pnpm install
   ```

## Usage
1. **Build the project**:
   ```bash
   pnpm run build
   ```
   This compiles the TypeScript files (`.mts`) to JavaScript (`.mjs`) and adjusts the service worker output.

2. **Serve the application**:
   Start the static server to view the app:
   ```bash
   pnpm start
   ```
   Open your browser to `http://localhost:8080`.

3. **Interact with the app**:
3. **Interact with the app**:
   - The SVG will load and scale to fit the window.
   - Click an element ID in the list under `#color-controls` (e.g., `#waves`) to open a color picker.
   - Select one of the 7 colors from the pop-up dialog to reassign it to the element.
   - Changes update the SVG in real-time.

4. **Deploy (optional)**:
   ```bash
   pnpm run deploy "Your commit message"
   ```
   This builds the project, commits changes, and pushes to the `main` branch. Adjust `scripts/deploy.sh` if your remote or branch differs.

## Project Structure
```
kjv-logo-coloring/
├── public/              # Static assets
│   ├── data/            # SVG file location
│   │   └── kjv-logo.svg # The logo SVG
│   ├── dist/            # Compiled JS (generated)
│   ├── index.html       # Main HTML entry point
│   ├── manifest.json    # Web app manifest
│   └── icon-192.png     # App icon
├── scripts/             # Build and deploy scripts
│   └── deploy.sh        # Deployment script
├── src/                 # Source code
│   ├── kjv-logo.mts     # Main app logic
│   └── service-worker.mts # Service worker logic
├── package.json         # Dependencies and scripts
├── tsconfig.json        # TypeScript configuration
└── README.md            # This file
```

## Development
- **Watch mode**: Rebuilds on file changes:
  ```bash
  pnpm run watch
  ```
- **TypeScript**: Uses `module: "NodeNext"` and `target: "esnext"` with strict type checking.
- **Dependencies**:
  - `typescript`: For compilation.
  - `tsc-alias`: Resolves `@/*` aliases in `src/`.
  - `nodemon`: Watches for changes in development.
  - `http-server`: Serves the static app locally.

## Notes
- The app relies on `kjv-logo.svg` having elements matching the IDs in `COLOR_GROUPS` (`#waves`, `#sky`, etc.).
- Colors are fixed but can be reassigned to any SVG element via the UI.
- Offline support is provided by the service worker, caching the SVG, HTML, and JS.

## License
This project is unlicensed by default. Add a `LICENSE` file if you wish to specify terms.

## Contributing
Feel free to fork and submit pull requests or open issues for bugs/features!
-----

===== package.json =====

{
  "name": "kjv-logo",
  "version": "0.0.1",
  "description": "KJV logo",
  "private": false,
  "scripts": {
    "build": "tsc && tsc-alias && sed -i '/export {};$/d' public/dist/service-worker.mjs && mv public/dist/service-worker.mjs public/service-worker.js",
    "deploy": "./scripts/deploy.sh",
    "fetch": "./scripts/fetch_events.sh",
    "watch": "nodemon -e mts,json,html,png,sh --exec pnpm run build",
    "report": "./scripts/files.sh README.md package.json tsconfig.json scripts/ src public/manifest.json public/index.html > kjv-logo.txt",
    "start": "http-server public -P http://localhost:8080?"
  },
  "dependencies": {},
  "devDependencies": {
    "typescript": "^5.7.3",
    "tsc-alias": "^1.8.10",
    "nodemon": "^3.1.9",
    "http-server": "^14.1.1"
  }
}
-----

===== tsconfig.json =====

{
  "compilerOptions": {
    "target": "esnext",                // Target ECMAScript next-generation output
    "outDir": "./public/dist",
    "module": "NodeNext",         
    "moduleResolution": "NodeNext",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "rootDirs": ["src"],  
  "include": ["src/**/*.mts", "src/**/*.ts"],
  "exclude": []                        // Exclude unnecessary files (e.g., test files, node_modules)
}

-----

===== scripts/files.sh =====

#!/bin/bash

# Default output is stdout (empty string means stdout in redirection), default pattern is all files
OUTPUT_FILE=""
FILE_PATTERNS=("*")  # Default to all files

# Usage message
usage() {
    echo "Usage: $0 [-o output_file] [-p pattern1 pattern2 ...] [files_or_directories...]"
    echo "  -o: Specify output file (default: stdout)"
    echo "  -p: File patterns to match (default: *)"
    echo "  files_or_directories: Files and/or directories to process (default: current directory)"
    exit 1
}

# Parse command-line options
while getopts "o:p:" opt; do
    case $opt in
        o) OUTPUT_FILE="$OPTARG" ;;
        p) IFS=' ' read -r -a FILE_PATTERNS <<< "$OPTARG" ;;
        ?) usage ;;
    esac
done
shift $((OPTIND - 1))

# If no arguments provided, default to current directory
if [ $# -eq 0 ]; then
    set -- "."
fi

# Build the find command with multiple patterns
FIND_ARGS=()
for pattern in "${FILE_PATTERNS[@]}"; do
    FIND_ARGS+=(-name "$pattern")
    if [ "$pattern" != "${FILE_PATTERNS[-1]}" ]; then
        FIND_ARGS+=(-o)
    fi
done

# Function to process a single path (file or directory)
process_path() {
    local path="$1"
    if [ -f "$path" ]; then
        # If it's a file, process it directly
        echo -e "===== $path =====\n"
        cat "$path"
        echo -e "\n-----\n"
    elif [ -d "$path" ]; then
        # If it's a directory, use find
        find "$path" -type f \( "${FIND_ARGS[@]}" \) -print0 | \
            xargs -0 -I {} /bin/bash -c 'echo -e "===== {} =====\n"; cat "{}"; echo -e "\n-----\n"'
    else
        echo "Warning: Skipping $path - not a file or directory" >&2
    fi
}

# Process all provided paths
if [ -z "$OUTPUT_FILE" ]; then
    # Output to stdout
    for path in "$@"; do
        process_path "$path"
    done
else
    # Output to file
    {
        for path in "$@"; do
            process_path "$path"
        done
    } > "$OUTPUT_FILE"
    echo "Combined files written to $OUTPUT_FILE"
fi
-----

===== scripts/deploy.sh =====

#!/bin/sh
msg="$1"
if [ -z "$msg" ]; then
  echo "Commit message required."
  exit 1
fi

pnpm run build && git add . && git commit -m "$msg" && git push -u origin main
-----

===== src/service-worker.mts =====

/// <reference lib="webworker" />
export type { };
declare const self: ServiceWorkerGlobalScope;

const CACHE_NAME = "kjv-logo";
const URLS_TO_CACHE = [
    "index.html",
    "dist/kjv-logo.mjs",
    "data/kjv-logo.svg",
    "icon-192.png",
];

self.addEventListener("install", (event: ExtendableEvent): void => {
    event.waitUntil(
        caches.open(CACHE_NAME).then((cache: Cache) => cache.addAll(URLS_TO_CACHE))
    );
});

self.addEventListener("fetch", (event: FetchEvent): void => {
    event.respondWith(
        (async (): Promise<Response> => {
            try {
                const response = await fetch(event.request);
                const responseClone = response.clone();
                caches.open(CACHE_NAME).then((cache: Cache) => {
                    cache.put(event.request, responseClone);
                });
                return response;
            } catch (e) {
                // If network fails, try to return a cached response
                return await caches.match(event.request)
                    ?? new Response('Offline content unavailable', {
                        status: 503,
                        statusText: 'Service Unavailable',
                        headers: { 'Content-Type': 'text/plain' }
                    });
            }
        })());
});
-----

===== src/kjv-logo.mts =====

/// <reference lib="dom" />

const DATA_URL: string = "./data/kjv-logo.svg";

// Define the fixed set of 7 colors (including white and transparent)
const COLORS: string[] = [
    "#434b72ff", // Dark blue
    "#bfd5e2ff", // Light blue
    "#00000000", // Transparent
    "#231f20ff", // Black
    "#f3df59ff", // Yellow
    "#689674ff", // Green
    "#ffffffff"  // White (new)
];

// Define initial color assignments for SVG elements
interface ColorGroups {
    [id: string]: string; // Map element IDs to colors
}

const COLOR_GROUPS: ColorGroups = {
    "#waves": "#434b72ff",           // Dark blue
    "#sky": "#bfd5e2ff",             // Light blue
    "#lettergap": "#00000000",       // Transparent
    "#garlandgap": "#00000000",      // Transparent
    "#letterborder": "#231f20ff",    // Black
    "#garlandborder": "#231f20ff",   // Black
    "#arcborder": "#231f20ff",       // Black
    "#yearbackground": "#f3df59ff",  // Yellow
    "#higherarc": "#f3df59ff",       // Yellow
    "#lowerarc": "#f3df59ff",        // Yellow
    "#letters": "#f3df59ff",         // Yellow
    "#leaves": "#689674ff"           // Green
};

// Persistent state for color assignments
let colorGroups: ColorGroups = { ...COLOR_GROUPS }; // Mutable copy of initial state
let svgElement: SVGSVGElement | null = null; // Store SVG for updates

// Load and display the SVG
async function loadSVG(): Promise<SVGSVGElement> {
    const response: Response = await fetch(DATA_URL);
    if (!response.ok) throw new Error("Failed to fetch SVG");
    const svgText: string = await response.text();
    const parser: DOMParser = new DOMParser();
    const svgDoc: Document = parser.parseFromString(svgText, "image/svg+xml");
    const svg = svgDoc.documentElement as unknown as SVGSVGElement;

    // Remove fill and stroke from style attributes of managed elements
    Object.keys(COLOR_GROUPS).forEach((id: string) => {
        const element: SVGElement | null = svg.querySelector(id);
        if (element && element.hasAttribute("style")) {
            const style = element.getAttribute("style")!;
            const styleMap = new Map(
                style.split(";").map((rule) => {
                    const [key, value] = rule.split(":").map((s) => s.trim());
                    return [key, value];
                })
            );
            styleMap.delete("fill");
            styleMap.delete("stroke");
            const newStyle = Array.from(styleMap.entries())
                .map(([key, value]) => `${key}:${value}`)
                .join(";");
            if (newStyle) {
                element.setAttribute("style", newStyle);
            } else {
                element.removeAttribute("style");
            }
        }
    });

    const container: HTMLElement = document.getElementById("svg-container")!;
    container.appendChild(svg);

    // Ensure SVG scales properly
    svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
    svg.removeAttribute("width");
    svg.removeAttribute("height");

    return svg;
}

// Update SVG element colors based on colorGroups
function updateElementColors(svg: SVGSVGElement): void {
    Object.entries(colorGroups).forEach(([id, color]: [string, string]) => {
        const element: SVGElement | null = svg.querySelector(id);
        if (element) {
            element.setAttribute("fill", color);
            element.setAttribute("stroke", color);
        } else {
            console.warn(`Element ${id} not found in SVG`);
        }
    });
}

// Create the element list and color picker UI
function createColorControls(svg: SVGSVGElement): void {
    const controls: HTMLElement = document.getElementById("color-controls")!;
    controls.innerHTML = ""; // Clear existing controls

    const list: HTMLUListElement = document.createElement("ul");
    list.className = "element-list";

    Object.keys(COLOR_GROUPS).forEach((id: string) => {
        const listItem: HTMLLIElement = document.createElement("li");
        listItem.textContent = id;
        listItem.className = "element-item";
        listItem.addEventListener("click", () => showColorPicker(id, svg));
        list.appendChild(listItem);
    });

    controls.appendChild(list);

    // Create the color picker dialog (hidden by default)
    const dialog: HTMLDivElement = document.createElement("div");
    dialog.id = "color-picker";
    dialog.className = "color-picker hidden";
    dialog.innerHTML = `
        <div class="color-options"></div>
        <button id="close-picker">Close</button>
    `;
    document.body.appendChild(dialog);

    const closeButton: HTMLButtonElement = dialog.querySelector("#close-picker")!;
    closeButton.addEventListener("click", () => dialog.classList.add("hidden"));
}

// Show the color picker for a specific element
function showColorPicker(id: string, svg: SVGSVGElement): void {
    const dialog: HTMLDivElement = document.getElementById("color-picker")! as HTMLDivElement;
    const optionsContainer: HTMLDivElement = dialog.querySelector(".color-options")!;
    optionsContainer.innerHTML = "";

    COLORS.forEach((color: string) => {
        const option: HTMLDivElement = document.createElement("div");
        option.className = "color-option";
        
        if (color === "#00000000") {
            // Create a checkerboard pattern using nested divs
            option.style.position = "relative";
            option.style.backgroundColor = "#ffffff"; // White base
            
            // Create checkerboard grid (2x2 pattern)
            for (let i = 0; i < 4; i++) {
                const square: HTMLDivElement = document.createElement("div");
                square.style.position = "absolute";
                square.style.width = "50%";
                square.style.height = "50%";
                
                // Position squares in checkerboard pattern
                if (i === 0) {
                    square.style.top = "0";
                    square.style.left = "0";
                    square.style.backgroundColor = "#808080"; // Gray squares
                } else if (i === 1) {
                    square.style.top = "50%";
                    square.style.left = "50%";
                    square.style.backgroundColor = "#808080"; // Gray squares
                } else if (i === 2) {
                    square.style.top = "50%";
                    square.style.left = "0";
                } else {
                    square.style.top = "0";
                    square.style.left = "50%";
                }
                
                option.appendChild(square);
            }
        } else {
            option.style.backgroundColor = color;
        }
        
        option.addEventListener("click", () => {
            colorGroups[id] = color;
            updateElementColors(svg);
            dialog.classList.add("hidden");
        });
        optionsContainer.appendChild(option);
    });

    dialog.classList.remove("hidden");

    // Position dialog near the clicked element
    const items = document.querySelectorAll(".element-item");
    const clickedItem = Array.from(items).find((item) => item.textContent === id);
    if (clickedItem) {
        const rect = clickedItem.getBoundingClientRect();
        dialog.style.top = `${rect.bottom + window.scrollY}px`;
        dialog.style.left = `${rect.left + window.scrollX}px`;
    }
}

// Initialize the application
async function initialize(): Promise<void> {
    try {
        svgElement = await loadSVG();
        updateElementColors(svgElement); // Initial render
        createColorControls(svgElement); // Build UI once
    } catch (error: unknown) {
        console.error("Error initializing:", error);
        const container: HTMLElement = document.getElementById("svg-container")!;
        container.innerText = "Failed to load SVG.";
    }
}

document.addEventListener("DOMContentLoaded", initialize);
-----

===== public/manifest.json =====

{
    "name": "KJV logo",
    "short_name": "KJV logo",
    "start_url": "/kjv-logo",
    "display": "standalone",
    "background_color": "#bfd5e2ff",
    "theme_color": "#689674ff",
    "icons": [
      {
        "src": "icon-192.png",
        "sizes": "192x192",
        "type": "image/png"
      }
    ]
  }
-----

===== public/index.html =====

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KJV Logo Coloring</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="icon-192.png">
    <script type="module" src="dist/kjv-logo.mjs"></script>
    <style>
        :root {
            --primary-color: #b9c6d2;
            --secondary-color: #d0dde9;
            --tertiary-color: #edf0f8;
        }

        body {
            background: linear-gradient(180deg, var(--primary-color) 0%, var(--secondary-color) 10.45%, var(--tertiary-color) 41.35%);
            font-family: Arial, sans-serif;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        #svg-container {
            max-width: 100%;
            max-height: 60vh;
            overflow: auto;
        }

        #svg-container svg {
            width: 100%;
            height: auto;
        }

        #color-controls {
            margin-top: 20px;
            width: 100%;
            max-width: 300px;
        }

        .element-list {
            list-style: none;
            padding: 0;
            border: 1px solid #231f20ff;
            background: rgba(255, 255, 255, 0.8);
        }

        .element-item {
            padding: 10px;
            cursor: pointer;
        }

        .element-item:hover {
            background-color: #f0f0f0;
        }

        .color-picker {
            position: absolute;
            border: 1px solid #231f20ff;
            padding: 10px;
            background: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .color-picker.hidden {
            display: none;
        }

        .color-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            cursor: pointer;
            background-repeat: repeat; /* Ensure checkerboard tiles */
        }

        .color-option:hover {
            border-color: #000;
        }

        #close-picker {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <div id="svg-container"></div>
    <div id="color-controls"></div>
</body>
</html>
-----

