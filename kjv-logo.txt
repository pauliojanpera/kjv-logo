===== README.md =====

\# KJV Logo Coloring

A simple web application for coloring the KJV logo SVG. Users can reassign predefined color categories to different elements of the logo, with the SVG dynamically updating based on their selections. Built with TypeScript, this project leverages modern web standards and includes offline support via a service worker.

\#\# Features
- Display and scale the \`kjv-logo.svg\` to fit the browser window.
- Six fixed color categories (dark blue, light blue, transparent, black, yellow, green) assignable to SVG elements.
- Interactive UI with multi-select dropdowns for color reassignment.
- Offline caching using a service worker.
- TypeScript-based with strict type checking.

\#\# Prerequisites
- \[Node.js\](https://nodejs.org/) (v16 or later recommended)
- \[pnpm\](https://pnpm.io/) (installed globally: \`npm install -g pnpm\`)

\#\# Installation
1. \*\*Clone the repository\*\*:
   \`\`\`bash
   git clone <repository-url>
   cd kjv-logo-coloring
   \`\`\`

2. \*\*Install dependencies\*\*:
   \`\`\`bash
   pnpm install
   \`\`\`

\#\# Usage
1. \*\*Build the project\*\*:
   \`\`\`bash
   pnpm run build
   \`\`\`
   This compiles the TypeScript files (\`.mts\`) to JavaScript (\`.mjs\`) and adjusts the service worker output.

2. \*\*Serve the application\*\*:
   Start the static server to view the app:
   \`\`\`bash
   pnpm start
   \`\`\`
   Open your browser to \`http://localhost:8080\`.

3. \*\*Interact with the app\*\*:
   - The SVG will load and scale to fit the window.
   - Use the dropdowns under \`#color-controls\` to reassign colors to SVG elements (e.g., move \`#waves\` from dark blue to yellow).
   - Changes update the SVG in real-time.

4. \*\*Deploy (optional)\*\*:
   \`\`\`bash
   pnpm run deploy "Your commit message"
   \`\`\`
   This builds the project, commits changes, and pushes to the \`main\` branch. Adjust \`scripts/deploy.sh\` if your remote or branch differs.

\#\# Project Structure
\`\`\`
kjv-logo-coloring/
├── public/              # Static assets
│   ├── data/            # SVG file location
│   │   └── kjv-logo.svg # The logo SVG
│   ├── dist/            # Compiled JS (generated)
│   ├── index.html       # Main HTML entry point
│   ├── manifest.json    # Web app manifest
│   └── icon-192.png     # App icon
├── scripts/             # Build and deploy scripts
│   └── deploy.sh        # Deployment script
├── src/                 # Source code
│   ├── kjv-logo.mts     # Main app logic
│   └── service-worker.mts # Service worker logic
├── package.json         # Dependencies and scripts
├── tsconfig.json        # TypeScript configuration
└── README.md            # This file
\`\`\`

\#\# Development
- \*\*Watch mode\*\*: Rebuilds on file changes:
  \`\`\`bash
  pnpm run watch
  \`\`\`
- \*\*TypeScript\*\*: Uses \`module: "NodeNext"\` and \`target: "esnext"\` with strict type checking.
- \*\*Dependencies\*\*:
  - \`typescript\`: For compilation.
  - \`tsc-alias\`: Resolves \`@/*\` aliases in \`src/\`.
  - \`nodemon\`: Watches for changes in development.
  - \`http-server\`: Serves the static app locally.

\#\# Notes
- The app relies on \`kjv-logo.svg\` having elements matching the IDs in \`COLOR_GROUPS\` (\`#waves\`, \`#sky\`, etc.).
- Colors are fixed but can be reassigned to any SVG element via the UI.
- Offline support is provided by the service worker, caching the SVG, HTML, and JS.

\#\# License
This project is unlicensed by default. Add a \`LICENSE\` file if you wish to specify terms.

\#\# Contributing
Feel free to fork and submit pull requests or open issues for bugs/features!
-----

===== package.json =====

{
  "name": "kjv-logo",
  "version": "0.0.1",
  "description": "KJV logo",
  "private": false,
  "scripts": {
    "build": "tsc && tsc-alias && sed -i '/export {};$/d' public/dist/service-worker.mjs && mv public/dist/service-worker.mjs public/service-worker.js",
    "deploy": "./scripts/deploy.sh",
    "fetch": "./scripts/fetch_events.sh",
    "watch": "nodemon -e mts,json,html,png,sh --exec pnpm run build",
    "report": "./scripts/files.sh README.md package.json tsconfig.json scripts/ src public/manifest.json public/index.html > kjv-logo.txt",
    "start": "http-server public -P http://localhost:8080?"
  },
  "dependencies": {},
  "devDependencies": {
    "typescript": "^5.7.3",
    "tsc-alias": "^1.8.10",
    "nodemon": "^3.1.9",
    "http-server": "^14.1.1"
  }
}
-----

===== tsconfig.json =====

{
  "compilerOptions": {
    "target": "esnext",                // Target ECMAScript next-generation output
    "outDir": "./public/dist",
    "module": "NodeNext",         
    "moduleResolution": "NodeNext",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "rootDirs": ["src"],  
  "include": ["src/**/*.mts", "src/**/*.ts"],
  "exclude": []                        // Exclude unnecessary files (e.g., test files, node_modules)
}

-----

===== scripts/files.sh =====

#!/bin/bash

# Default output is stdout (empty string means stdout in redirection), default pattern is all files
OUTPUT_FILE=""
FILE_PATTERNS=("*")  # Default to all files

# Usage message
usage() {
    echo "Usage: $0 [-o output_file] [-p pattern1 pattern2 ...] [files_or_directories...]"
    echo "  -o: Specify output file (default: stdout)"
    echo "  -p: File patterns to match (default: *)"
    echo "  files_or_directories: Files and/or directories to process (default: current directory)"
    exit 1
}

# Parse command-line options
while getopts "o:p:" opt; do
    case $opt in
        o) OUTPUT_FILE="$OPTARG" ;;
        p) IFS=' ' read -r -a FILE_PATTERNS <<< "$OPTARG" ;;
        ?) usage ;;
    esac
done
shift $((OPTIND - 1))

# If no arguments provided, default to current directory
if [ $# -eq 0 ]; then
    set -- "."
fi

# Build the find command with multiple patterns
FIND_ARGS=()
for pattern in "${FILE_PATTERNS[@]}"; do
    FIND_ARGS+=(-name "$pattern")
    if [ "$pattern" != "${FILE_PATTERNS[-1]}" ]; then
        FIND_ARGS+=(-o)
    fi
done

# Function to process a single path (file or directory)
process_path() {
    local path="$1"
    if [ -f "$path" ]; then
        # If it's a file, process it directly
        echo -e "===== $path =====\n"
        cat "$path"
        echo -e "\n-----\n"
    elif [ -d "$path" ]; then
        # If it's a directory, use find
        find "$path" -type f \( "${FIND_ARGS[@]}" \) -print0 | \
            xargs -0 -I {} /bin/bash -c 'echo -e "===== {} =====\n"; cat "{}"; echo -e "\n-----\n"'
    else
        echo "Warning: Skipping $path - not a file or directory" >&2
    fi
}

# Process all provided paths
if [ -z "$OUTPUT_FILE" ]; then
    # Output to stdout
    for path in "$@"; do
        process_path "$path"
    done
else
    # Output to file
    {
        for path in "$@"; do
            process_path "$path"
        done
    } > "$OUTPUT_FILE"
    echo "Combined files written to $OUTPUT_FILE"
fi
-----

===== scripts/deploy.sh =====

#!/bin/sh
msg="$1"
if [ -z "$msg" ]; then
  echo "Commit message required."
  exit 1
fi

pnpm run build && git add . && git commit -m "$msg" && git push -u origin main
-----

===== src/service-worker.mts =====

/// <reference lib="webworker" />
export type { };
declare const self: ServiceWorkerGlobalScope;

const CACHE_NAME = "kjv-logo";
const URLS_TO_CACHE = [
    "index.html",
    "dist/kjv-logo.mjs",
    "data/kjv-logo.svg",
    "icon-192.png",
];

self.addEventListener("install", (event: ExtendableEvent): void => {
    event.waitUntil(
        caches.open(CACHE_NAME).then((cache: Cache) => cache.addAll(URLS_TO_CACHE))
    );
});

self.addEventListener("fetch", (event: FetchEvent): void => {
    event.respondWith(
        (async (): Promise<Response> => {
            try {
                const response = await fetch(event.request);
                const responseClone = response.clone();
                caches.open(CACHE_NAME).then((cache: Cache) => {
                    cache.put(event.request, responseClone);
                });
                return response;
            } catch (e) {
                // If network fails, try to return a cached response
                return await caches.match(event.request)
                    ?? new Response('Offline content unavailable', {
                        status: 503,
                        statusText: 'Service Unavailable',
                        headers: { 'Content-Type': 'text/plain' }
                    });
            }
        })());
});
-----

===== src/kjv-logo.mts =====

/// <reference lib="dom" />

const DATA_URL: string = "./data/kjv-logo.svg";

// Define the color groups with their initial element IDs
interface ColorGroups {
    [color: string]: string[];
}

const COLOR_GROUPS: ColorGroups = {
    "#434b72ff": ["#waves"],           // Dark blue
    "#bfd5e2ff": ["#sky"],             // Light blue
    "#00000000": ["#lettergap", "#garlandgap"], // Transparent
    "#231f20ff": ["#letterborder", "#garlandborder", "#arcborder"], // Black
    "#f3df59ff": ["#yearbackground", "#higherarc", "#lowerarc", "#letters"], // Yellow
    "#689674ff": ["#leaves"]           // Green
};

// Persistent state for color assignments
let colorGroups: ColorGroups = { ...COLOR_GROUPS }; // Mutable copy of initial state
let colorSelects: Map<string, HTMLSelectElement> = new Map(); // Store select elements by color

// Load and display the SVG
async function loadSVG(): Promise<SVGSVGElement> {
    const response: Response = await fetch(DATA_URL);
    if (!response.ok) throw new Error("Failed to fetch SVG");
    const svgText: string = await response.text();
    const parser: DOMParser = new DOMParser();
    const svgDoc: Document = parser.parseFromString(svgText, "image/svg+xml");
    const svgElement = svgDoc.documentElement as unknown as SVGSVGElement;

    const container: HTMLElement = document.getElementById("svg-container")!;
    container.appendChild(svgElement);

    // Ensure SVG scales properly
    svgElement.setAttribute("preserveAspectRatio", "xMidYMid meet");
    svgElement.removeAttribute("width"); // Let CSS handle sizing
    svgElement.removeAttribute("height");

    return svgElement;
}

// Update the fill and stroke of SVG elements based on color groups
function updateElementColors(svg: SVGSVGElement, groups: ColorGroups = colorGroups): void {
    console.log("Updating SVG with color groups:", groups); // Log the current state
    Object.entries(groups).forEach(([color, ids]: [string, string[]]) => {
        ids.forEach((id: string) => {
            const element: SVGElement | null = svg.querySelector(id);
            if (element) {
                console.log(`Setting ${id} to color ${color}`); // Log each update
                element.setAttribute("fill", color);
                element.setAttribute("stroke", color);
            } else {
                console.warn(`Element ${id} not found in SVG`); // Warn if ID is missing
            }
        });
    });
}

// Update the UI to reflect current colorGroups state
function updateColorControls(): void {
    colorSelects.forEach((select: HTMLSelectElement, color: string) => {
        const currentIds: string[] = colorGroups[color] || [];
        Array.from(select.options).forEach((option: HTMLOptionElement) => {
            option.selected = currentIds.includes(option.value);
        });
    });
}

// Create the color reassignment UI (called only once)
function createColorControls(svg: SVGSVGElement): void {
    const controls: HTMLElement = document.getElementById("color-controls")!;
    controls.innerHTML = ""; // Clear existing controls

    const allIds: string[] = Object.values(COLOR_GROUPS).flat(); // All possible element IDs

    Object.entries(colorGroups).forEach(([color, ids]: [string, string[]]) => {
        const groupDiv: HTMLDivElement = document.createElement("div");
        groupDiv.className = "color-group";

        const colorSwatch: HTMLDivElement = document.createElement("div");
        colorSwatch.style.width = "20px";
        colorSwatch.style.height = "20px";
        colorSwatch.style.backgroundColor = color;
        colorSwatch.style.display = "inline-block";
        colorSwatch.style.marginRight = "10px";

        const select: HTMLSelectElement = document.createElement("select");
        select.multiple = true;
        select.size = 5;

        // Populate with all possible elements
        allIds.forEach((id: string) => {
            const option: HTMLOptionElement = document.createElement("option");
            option.value = id;
            option.textContent = id;
            option.selected = ids.includes(id);
            select.appendChild(option);
        });

        // Store the select element
        colorSelects.set(color, select);

        // Update color group on change
        select.addEventListener("change", () => {
            const selectedIds: string[] = Array.from(select.selectedOptions).map((opt: HTMLOptionElement) => opt.value);
            console.log('selectedIds', JSON.stringify(selectedIds));
            // Update the current color's group
            colorGroups[color] = selectedIds;

            // Remove selected IDs from other groups to prevent overlap
            Object.keys(colorGroups).forEach((otherColor: string) => {
                if (otherColor !== color) {
                    colorGroups[otherColor] = colorGroups[otherColor].filter((id: string) => !selectedIds.includes(id));
                }
            });

            // Update the SVG and UI
            updateElementColors(svg);
            updateColorControls(); // Update dropdowns without rebuilding
        });

        groupDiv.appendChild(colorSwatch);
        groupDiv.appendChild(select);
        controls.appendChild(groupDiv);
    });
}

// Initialize the application
async function initialize(): Promise<void> {
    try {
        const svg: SVGSVGElement = await loadSVG();
        updateElementColors(svg); // Initial render
        createColorControls(svg); // Build UI once
    } catch (error: unknown) {
        console.error("Error initializing:", error);
        const container: HTMLElement = document.getElementById("svg-container")!;
        container.innerText = "Failed to load SVG.";
    }
}

document.addEventListener("DOMContentLoaded", initialize);
-----

===== public/manifest.json =====

{
    "name": "KJV logo",
    "short_name": "KJV logo",
    "start_url": "/kjv-logo",
    "display": "standalone",
    "background_color": "#bfd5e2ff",
    "theme_color": "#689674ff",
    "icons": [
      {
        "src": "icon-192.png",
        "sizes": "192x192",
        "type": "image/png"
      }
    ]
  }
-----

===== public/index.html =====

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KJV Logo Coloring</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="icon-192.png">
    <script type="module" src="dist/kjv-logo.mjs"></script>
    <style>
        :root {
            --primary-color: #b9c6d2;
            --secondary-color: #d0dde9;
            --tertiary-color: #edf0f8;
        }

        body {
            background: linear-gradient(180deg, var(--primary-color) 0%, var(--secondary-color) 10.45%, var(--tertiary-color) 41.35%);
            font-family: Arial, sans-serif;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        #svg-container {
            max-width: 100%;
            max-height: 60vh;
            overflow: auto;
        }

        #svg-container svg {
            width: 100%;
            height: auto;
        }

        #color-controls {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .color-group {
            border: 1px solid #231f20ff;
            padding: 10px;
            background: rgba(255, 255, 255, 0.8);
        }
    </style>
</head>
<body>
    <div id="svg-container"></div>
    <div id="color-controls"></div>
</body>
</html>
-----

