===== README.md =====

# KJV logo

A simple web application for coloring the KJV logo SVG. Users can reassign predefined color categories to different elements of the logo, with the SVG dynamically updating based on their selections. Built with TypeScript, this project leverages modern web standards and includes offline support via a service worker.

## Features
- Display and scale the `kjv-logo.svg` to fit the browser window.
- Seven fixed colors (dark blue, light blue, transparent, black, yellow, green, white) assignable to SVG elements.
- Interactive UI with a list of element IDs; click an ID to open a color picker dialog.
- Offline caching using a service worker.
- TypeScript-based with strict type checking.

## Prerequisites
- [Node.js](https://nodejs.org/) (v16 or later recommended)
- [pnpm](https://pnpm.io/) (installed globally: `npm install -g pnpm`)

## Installation
1. **Clone the repository**:
   ```bash
   git clone <repository-url>
   cd kjv-logo-coloring
   ```

2. **Install dependencies**:
   ```bash
   pnpm install
   ```

## Usage
1. **Build the project**:
   ```bash
   pnpm run build
   ```
   This compiles the TypeScript files (`.mts`) to JavaScript (`.mjs`) and adjusts the service worker output.

2. **Serve the application**:
   Start the static server to view the app:
   ```bash
   pnpm start
   ```
   Open your browser to `http://localhost:8080`.

3. **Interact with the app**:
3. **Interact with the app**:
   - The SVG will load and scale to fit the window.
   - Click an element ID in the list under `#color-controls` (e.g., `#waves`) to open a color picker.
   - Select one of the 7 colors from the pop-up dialog to reassign it to the element.
   - Changes update the SVG in real-time.

4. **Deploy (optional)**:
   ```bash
   pnpm run deploy "Your commit message"
   ```
   This builds the project, commits changes, and pushes to the `main` branch. Adjust `scripts/deploy.sh` if your remote or branch differs.

## Project Structure
```
kjv-logo-coloring/
├── public/              # Static assets
│   ├── data/            # SVG file location
│   │   └── kjv-logo.svg # The logo SVG
│   ├── dist/            # Compiled JS (generated)
│   ├── index.html       # Main HTML entry point
│   ├── manifest.json    # Web app manifest
│   └── icon-192.png     # App icon
├── scripts/             # Build and deploy scripts
│   └── deploy.sh        # Deployment script
├── src/                 # Source code
│   ├── kjv-logo.mts     # Main app logic
│   └── service-worker.mts # Service worker logic
├── package.json         # Dependencies and scripts
├── tsconfig.json        # TypeScript configuration
└── README.md            # This file
```

## Development
- **Watch mode**: Rebuilds on file changes:
  ```bash
  pnpm run watch
  ```
- **TypeScript**: Uses `module: "NodeNext"` and `target: "esnext"` with strict type checking.
- **Dependencies**:
  - `typescript`: For compilation.
  - `tsc-alias`: Resolves `@/*` aliases in `src/`.
  - `nodemon`: Watches for changes in development.
  - `http-server`: Serves the static app locally.

## Notes
- The app relies on `kjv-logo.svg` having elements matching the IDs in `COLOR_GROUPS` (`#waves`, `#sky`, etc.).
- Colors are fixed but can be reassigned to any SVG element via the UI.
- Offline support is provided by the service worker, caching the SVG, HTML, and JS.

## License
This project is unlicensed by default. Add a `LICENSE` file if you wish to specify terms.

## Contributing
Feel free to fork and submit pull requests or open issues for bugs/features!
-----

===== package.json =====

{
  "name": "kjv-logo",
  "version": "0.0.1",
  "description": "KJV logo",
  "private": false,
  "scripts": {
    "build": "tsc && tsc-alias && sed -i '/export {};$/d' public/dist/service-worker.mjs && mv public/dist/service-worker.mjs public/service-worker.js",
    "deploy": "./scripts/deploy.sh",
    "fetch": "./scripts/fetch_events.sh",
    "watch": "nodemon -e mts,json,html,png,sh --exec pnpm run build",
    "report": "./scripts/files.sh README.md package.json tsconfig.json .github/workflows/static.yml scripts/ src public/manifest.json public/index.html > kjv-logo.txt",
    "start": "http-server public -P http://localhost:8080?"
  },
  "dependencies": {},
  "devDependencies": {
    "typescript": "^5.7.3",
    "tsc-alias": "^1.8.10",
    "nodemon": "^3.1.9",
    "http-server": "^14.1.1"
  }
}
-----

===== tsconfig.json =====

{
  "compilerOptions": {
    "target": "esnext",                // Target ECMAScript next-generation output
    "outDir": "./public/dist",
    "module": "NodeNext",         
    "moduleResolution": "NodeNext",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "rootDirs": ["src"],  
  "include": ["src/**/*.mts", "src/**/*.ts"],
  "exclude": []                        // Exclude unnecessary files (e.g., test files, node_modules)
}

-----

===== .github/workflows/static.yml =====

# Simple workflow for deploying static content to GitHub Pages
name: Deploy static content to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  workflow_run:
    workflows: ["Update Event Data"]
    types:
      - completed

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Single deploy job since we're just deploying
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: './public'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

-----

===== scripts/files.sh =====

#!/bin/bash

# Default output is stdout (empty string means stdout in redirection), default pattern is all files
OUTPUT_FILE=""
FILE_PATTERNS=("*")  # Default to all files

# Usage message
usage() {
    echo "Usage: $0 [-o output_file] [-p pattern1 pattern2 ...] [files_or_directories...]"
    echo "  -o: Specify output file (default: stdout)"
    echo "  -p: File patterns to match (default: *)"
    echo "  files_or_directories: Files and/or directories to process (default: current directory)"
    exit 1
}

# Parse command-line options
while getopts "o:p:" opt; do
    case $opt in
        o) OUTPUT_FILE="$OPTARG" ;;
        p) IFS=' ' read -r -a FILE_PATTERNS <<< "$OPTARG" ;;
        ?) usage ;;
    esac
done
shift $((OPTIND - 1))

# If no arguments provided, default to current directory
if [ $# -eq 0 ]; then
    set -- "."
fi

# Build the find command with multiple patterns
FIND_ARGS=()
for pattern in "${FILE_PATTERNS[@]}"; do
    FIND_ARGS+=(-name "$pattern")
    if [ "$pattern" != "${FILE_PATTERNS[-1]}" ]; then
        FIND_ARGS+=(-o)
    fi
done

# Function to process a single path (file or directory)
process_path() {
    local path="$1"
    if [ -f "$path" ]; then
        # If it's a file, process it directly
        echo -e "===== $path =====\n"
        cat "$path"
        echo -e "\n-----\n"
    elif [ -d "$path" ]; then
        # If it's a directory, use find
        find "$path" -type f \( "${FIND_ARGS[@]}" \) -print0 | \
            xargs -0 -I {} /bin/bash -c 'echo -e "===== {} =====\n"; cat "{}"; echo -e "\n-----\n"'
    else
        echo "Warning: Skipping $path - not a file or directory" >&2
    fi
}

# Process all provided paths
if [ -z "$OUTPUT_FILE" ]; then
    # Output to stdout
    for path in "$@"; do
        process_path "$path"
    done
else
    # Output to file
    {
        for path in "$@"; do
            process_path "$path"
        done
    } > "$OUTPUT_FILE"
    echo "Combined files written to $OUTPUT_FILE"
fi
-----

===== scripts/deploy.sh =====

#!/bin/sh
msg="$1"
if [ -z "$msg" ]; then
  echo "Commit message required."
  exit 1
fi

pnpm run build && git add . && git commit -m "$msg" && git push -u origin main
-----

===== src/service-worker.mts =====

/// <reference lib="webworker" />
export type { };
declare const self: ServiceWorkerGlobalScope;

const CACHE_NAME = "kjv-logo";
const URLS_TO_CACHE = [
    "index.html",
    "dist/kjv-logo.mjs",
    "data/kjv-logo.svg",
    "icon-192.png",
];

self.addEventListener("install", (event: ExtendableEvent): void => {
    event.waitUntil(
        caches.open(CACHE_NAME).then((cache: Cache) => cache.addAll(URLS_TO_CACHE))
    );
});

self.addEventListener("fetch", (event: FetchEvent): void => {
    event.respondWith(
        (async (): Promise<Response> => {
            try {
                const response = await fetch(event.request);
                const responseClone = response.clone();
                caches.open(CACHE_NAME).then((cache: Cache) => {
                    cache.put(event.request, responseClone);
                });
                return response;
            } catch (e) {
                // If network fails, try to return a cached response
                return await caches.match(event.request)
                    ?? new Response('Offline content unavailable', {
                        status: 503,
                        statusText: 'Service Unavailable',
                        headers: { 'Content-Type': 'text/plain' }
                    });
            }
        })());
});
-----

===== src/kjv-logo.mts =====

/// <reference lib="dom" />

const DATA_URL: string = "./data/kjv-logo.svg";

// Define the fixed set of 7 colors (including white and transparent)
const COLORS: string[] = [
    "#434b72ff", // Dark blue
    "#bfd5e2ff", // Light blue
    "#00000000", // Transparent
    "#231f20ff", // Black
    "#f3df59ff", // Yellow
    "#689674ff", // Green
    "#ffffffff"  // White
];

// Define initial color assignments for SVG elements
interface ColorGroups {
    [id: string]: string; // Map element IDs to colors
}

const COLOR_GROUPS: ColorGroups = {
    "#waves": "#434b72ff",           // Dark blue
    "#sky": "#bfd5e2ff",             // Light blue
    "#lettergap": "#00000000",       // Transparent
    "#garlandgap": "#00000000",      // Transparent
    "#letterborder": "#231f20ff",    // Black
    "#garlandborder": "#231f20ff",   // Black
    "#arcborder": "#231f20ff",       // Black
    "#yearbackground": "#f3df59ff",  // Yellow
    "#higherarc": "#f3df59ff",       // Yellow
    "#lowerarc": "#f3df59ff",        // Yellow
    "#letters": "#f3df59ff",         // Yellow
    "#leaves": "#689674ff"           // Green
};

// Persistent state for color assignments
let colorGroups: ColorGroups = { ...COLOR_GROUPS }; // Mutable copy of initial state
let svgElement: SVGSVGElement | null = null; // Store SVG for updates

// Load and display the SVG
async function loadSVG(): Promise<SVGSVGElement> {
    const response: Response = await fetch(DATA_URL);
    if (!response.ok) throw new Error("Failed to fetch SVG");
    const svgText: string = await response.text();
    const parser: DOMParser = new DOMParser();
    const svgDoc: Document = parser.parseFromString(svgText, "image/svg+xml");
    const svg = svgDoc.documentElement as unknown as SVGSVGElement;

    // Remove fill and stroke from style attributes of managed elements
    Object.keys(COLOR_GROUPS).forEach((id: string) => {
        const element: SVGElement | null = svg.querySelector(id);
        if (element && element.hasAttribute("style")) {
            const style = element.getAttribute("style")!;
            const styleMap = new Map(
                style.split(";").map((rule) => {
                    const [key, value] = rule.split(":").map((s) => s.trim());
                    return [key, value];
                })
            );
            styleMap.delete("fill");
            styleMap.delete("stroke");
            const newStyle = Array.from(styleMap.entries())
                .map(([key, value]) => `${key}:${value}`)
                .join(";");
            if (newStyle) {
                element.setAttribute("style", newStyle);
            } else {
                element.removeAttribute("style");
            }
        }
    });

    const container: HTMLElement = document.getElementById("svg-container")!;
    container.appendChild(svg);

    // Ensure SVG scales properly
    svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
    svg.removeAttribute("width");
    svg.removeAttribute("height");

    return svg;
}

// Update SVG element colors based on colorGroups
function updateElementColors(svg: SVGSVGElement): void {
    Object.entries(colorGroups).forEach(([id, color]: [string, string]) => {
        const element: SVGElement | null = svg.querySelector(id);
        if (element) {
            element.setAttribute("fill", color);
            element.setAttribute("stroke", color);
        } else {
            console.warn(`Element ${id} not found in SVG`);
        }
    });
}

// Set up color picker and SVG click handlers
function setupColorPicker(svg: SVGSVGElement): void {
    // Create the color picker dialog (hidden by default)
    const dialog: HTMLDivElement = document.createElement("div");
    dialog.id = "color-picker";
    dialog.className = "color-picker hidden";
    dialog.innerHTML = `
        <div class="color-options"></div>
        <button id="close-picker">Close</button>
    `;
    document.body.appendChild(dialog);

    const closeButton: HTMLButtonElement = dialog.querySelector("#close-picker")!;
    closeButton.addEventListener("click", () => dialog.classList.add("hidden"));

    // Add click event listeners to SVG elements
    Object.keys(COLOR_GROUPS).forEach((id: string) => {
        const element: SVGElement | null = svg.querySelector(id);
        if (element) {
            element.style.cursor = "pointer"; // Visual feedback
            element.addEventListener("click", () => showColorPicker(id, svg));
        } else {
            console.warn(`Element ${id} not found in SVG for click listener`);
        }
    });
}

let currentlyHighlightedElement: SVGElement | null = null; // Track the highlighted element

function showColorPicker(id: string, svg: SVGSVGElement): void {
    const dialog: HTMLDivElement = document.getElementById("color-picker")! as HTMLDivElement;
    const optionsContainer: HTMLDivElement = dialog.querySelector(".color-options")!;
    optionsContainer.innerHTML = "";

    // Remove highlight from previously highlighted element
    if (currentlyHighlightedElement) {
        currentlyHighlightedElement.classList.remove("highlight-pulse");
    }

    // Add highlight to the current target element
    const targetElement: SVGElement | null = svg.querySelector(id);
    if (targetElement) {
        targetElement.classList.add("highlight-pulse");
        currentlyHighlightedElement = targetElement; // Update tracking
    } else {
        console.warn(`Element ${id} not found in SVG for highlighting`);
    }

    COLORS.forEach((color: string) => {
        const option: HTMLDivElement = document.createElement("div");
        option.className = "color-option";
        
        if (color === "#00000000") {
            option.style.position = "relative";
            option.style.backgroundColor = "#ffffff";
            for (let i = 0; i < 4; i++) {
                const square: HTMLDivElement = document.createElement("div");
                square.style.position = "absolute";
                square.style.width = "50%";
                square.style.height = "50%";
                if (i === 0) {
                    square.style.top = "0";
                    square.style.left = "0";
                    square.style.backgroundColor = "#808080";
                } else if (i === 1) {
                    square.style.top = "50%";
                    square.style.left = "50%";
                    square.style.backgroundColor = "#808080";
                } else if (i === 2) {
                    square.style.top = "50%";
                    square.style.left = "0";
                } else {
                    square.style.top = "0";
                    square.style.left = "50%";
                }
                option.appendChild(square);
            }
        } else {
            option.style.backgroundColor = color;
        }
        
        option.addEventListener("click", () => {
            colorGroups[id] = color;
            updateElementColors(svg);
            dialog.classList.add("hidden");
            if (currentlyHighlightedElement) {
                currentlyHighlightedElement.classList.remove("highlight-pulse");
                currentlyHighlightedElement = null;
            }
        });
        optionsContainer.appendChild(option);
    });

    dialog.classList.remove("hidden");

    // Position dialog near the SVG element
    if (targetElement) {
        const rect = targetElement.getBoundingClientRect();
        dialog.style.top = `${rect.bottom + window.scrollY}px`;
        dialog.style.left = `${rect.left + window.scrollX}px`;
    } else {
        dialog.style.top = "50%";
        dialog.style.left = "50%";
        dialog.style.transform = "translate(-50%, -50%)";
    }

    const closeButton: HTMLButtonElement = dialog.querySelector("#close-picker")!;
    closeButton.onclick = () => {
        dialog.classList.add("hidden");
        if (currentlyHighlightedElement) {
            currentlyHighlightedElement.classList.remove("highlight-pulse");
            currentlyHighlightedElement = null;
        }
    };
}

// Initialize the application
async function initialize(): Promise<void> {
    try {
        svgElement = await loadSVG();
        updateElementColors(svgElement); // Initial render
        setupColorPicker(svgElement); // Set up color picker and click handlers
    } catch (error: unknown) {
        console.error("Error initializing:", error);
        const container: HTMLElement = document.getElementById("svg-container")!;
        container.innerText = "Failed to load SVG.";
    }
}

document.addEventListener("DOMContentLoaded", initialize);
-----

===== public/manifest.json =====

{
    "name": "KJV logo",
    "short_name": "KJV logo",
    "start_url": "/kjv-logo",
    "display": "standalone",
    "background_color": "#bfd5e2ff",
    "theme_color": "#689674ff",
    "icons": [
      {
        "src": "icon-192.png",
        "sizes": "192x192",
        "type": "image/png"
      }
    ]
  }
-----

===== public/index.html =====

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KJV logo</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="icon-192.png">
    <script type="module" src="dist/kjv-logo.mjs"></script>
    <style>
        :root {
            --primary-color: #b9c6d2;
            --secondary-color: #d0dde9;
            --tertiary-color: #edf0f8;
        }

        body {
            background: linear-gradient(180deg, var(--primary-color) 0%, var(--secondary-color) 10.45%, var(--tertiary-color) 41.35%);
            font-family: Arial, sans-serif;
            min-height: 100dvh;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        #svg-container {
            flex-grow: 1;
            max-width: 100%;
            max-height: 100vh;
            overflow: auto;
        }

        #svg-container svg {
            width: 100%;
            height: auto;
        }

        .color-picker {
            position: absolute;
            border: 1px solid #231f20ff;
            padding: 10px;
            background: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .color-picker.hidden {
            display: none;
        }

        .color-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            cursor: pointer;
            background-repeat: repeat;
        }

        .color-option:hover {
            border-color: #000;
        }

        #close-picker {
            display: block;
            margin: 0 auto;
        }

        @keyframes pulse {
            0% {
                stroke: red;
                fill: red;
            }
            50% {
                stroke: white;
                fill: white;
            }
            100% {
                stroke: red;
                fill: red;
            }
        }

        .highlight-pulse {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <div id="svg-container"></div>
</body>
</html>
-----

